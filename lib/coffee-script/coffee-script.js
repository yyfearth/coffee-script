// Generated by eXtraCoffeeScript 1.2.0q
(function() {
  var EXTENSIONS, Lexer, RESERVED, compile, e, fs, iced, imports, isCoffeeFile, lexer, parser, path, vm, _i, _j, _len, _len2, _ref,
    __hasProp = {}.hasOwnProperty;

  fs = require('fs');

  path = require('path');

  _ref = require('./lexer'), Lexer = _ref.Lexer, RESERVED = _ref.RESERVED;

  parser = require('./parser').parser;

  vm = require('vm');

  iced = require('./iced');

  exports.EXTENSIONS = EXTENSIONS = [".coffee", ".xcoffee", ".iced"];

  isCoffeeFile = function(file) {
    var e, _i, _len;
    for (_i = 0, _len = EXTENSIONS.length; _i < _len; _i++) {
      e = EXTENSIONS[_i];
      if (path.extname(file) === e) return true;
    }
    return false;
  };

  if (require.extensions) {
    for (_i = 0, _len = EXTENSIONS.length; _i < _len; _i++) {
      e = EXTENSIONS[_i];
      require.extensions[e] = function(module, filename) {
        var content;
        content = compile(fs.readFileSync(filename, 'utf8'), {
          filename: filename
        });
        return module._compile(content, filename);
      };
    }
  } else if (require.registerExtension) {
    for (_j = 0, _len2 = EXTENSIONS.length; _j < _len2; _j++) {
      e = EXTENSIONS[_j];
      require.registerExtension(e, function(content) {
        return compile(content);
      });
    }
  }

  exports.VERSION = '1.2.0q';

  exports.RESERVED = RESERVED;

  exports.helpers = require('./helpers');

  exports.imports = imports = function(code, options) {
    var chk_file, cwd, filename, imported, parse, regex, regex_g;
    if (options == null) options = {};
    regex = options.regex || /^\s*import\s+['"](.+)['"][;\s]*$/;
    regex_g = new RegExp(regex.source, 'gm');
    chk_file = function(filename) {
      var stats;
      try {
        stats = fs.lstatSync(filename);
        return !stats.isDirectory();
      } catch (e) {
        return false;
      }
    };
    filename = options.filename || null;
    cwd = process.cwd();
    imported = {};
    return (parse = function(code, filename) {
      return code.replace(regex_g, function(match) {
        var dir, ext, exts, f, import_code, is_js, rmk, _filename, _is_js;
        match = match.match(regex);
        dir = filename ? path.dirname(fs.realpathSync(filename)) : cwd;
        _filename = f = path.resolve(dir, match[1]);
        if (!chk_file(_filename)) {
          _filename = null;
          exts = EXTENSIONS.concat(['.js']);
          while (!_filename && (ext = exts.shift())) {
            if (chk_file(f + ext)) _filename = f + ext;
          }
          if (!_filename) throw "In " + filename + ", cannot find import: " + f;
        }
        if (imported[_filename]) {
          throw "In " + filename + ", find duplicate import: " + _filename;
        }
        is_js = /\.js$/.test(filename);
        _is_js = /\.js$/.test(_filename);
        if (is_js && !_is_js) {
          throw "In " + filename + ", Js file cannot include non-js file " + _filename;
        }
        import_code = fs.readFileSync(_filename, 'utf8');
        imported[_filename] = true;
        import_code = parse(import_code, _filename);
        if (is_js !== _is_js) import_code = "`" + import_code + "`";
        rmk = /\.js$/.test(filename) ? "/* imported " + _filename + " */" : "### imported " + _filename + " ###";
        return "" + rmk + "\n" + import_code + "\n\n";
      });
    })(code, filename);
  };

  exports.compile = compile = function(code, options) {
    var header, js, merge;
    if (options == null) options = {};
    if (options.imports) code = imports(code, options);
    merge = exports.helpers.merge;
    try {
      js = (iced.transform(parser.parse(lexer.tokenize(code)))).compile(options);
      if (!options.header) return js;
    } catch (err) {
      if (options.imports) console.log('imported finished code:', code);
      if (options.filename) {
        err.message = "In " + options.filename + ", " + err.message;
      }
      throw err;
    }
    header = typeof options.header === 'string' ? options.header : "Generated by eXtraCoffeeScript " + this.VERSION;
    return "// " + header + "\n" + js;
  };

  exports.tokens = function(code, options) {
    return lexer.tokenize(code, options);
  };

  exports.nodes = function(source, options) {
    if (typeof source === 'string') {
      return iced.transform(parser.parse(lexer.tokenize(source, options)));
    } else {
      return iced.transform(parser.parse(source));
    }
  };

  exports.run = function(code, options) {
    var mainModule;
    if (options == null) options = {};
    mainModule = require.main;
    mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : '.';
    mainModule.moduleCache && (mainModule.moduleCache = {});
    mainModule.paths = require('module')._nodeModulePaths(path.dirname(options.filename));
    if ((!isCoffeeFile(mainModule.filename)) || require.extensions) {
      return mainModule._compile(compile(code, options), mainModule.filename);
    } else {
      return mainModule._compile(code, mainModule.filename);
    }
  };

  exports["eval"] = function(code, options) {
    var Module, Script, js, k, o, r, sandbox, v, _k, _len3, _module, _ref2, _ref3, _require;
    if (options == null) options = {};
    if (!(code = code.trim())) return;
    Script = vm.Script;
    if (Script) {
      if (options.sandbox != null) {
        if (options.sandbox instanceof Script.createContext().constructor) {
          sandbox = options.sandbox;
        } else {
          sandbox = Script.createContext();
          _ref2 = options.sandbox;
          for (k in _ref2) {
            if (!__hasProp.call(_ref2, k)) continue;
            v = _ref2[k];
            sandbox[k] = v;
          }
        }
        sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
      } else {
        sandbox = global;
      }
      sandbox.__filename = options.filename || 'eval';
      sandbox.__dirname = path.dirname(sandbox.__filename);
      if (!(sandbox !== global || sandbox.module || sandbox.require)) {
        Module = require('module');
        sandbox.module = _module = new Module(options.modulename || 'eval');
        sandbox.require = _require = function(path) {
          return Module._load(path, _module, true);
        };
        _module.filename = sandbox.__filename;
        _ref3 = Object.getOwnPropertyNames(require);
        for (_k = 0, _len3 = _ref3.length; _k < _len3; _k++) {
          r = _ref3[_k];
          if (r !== 'paths') _require[r] = require[r];
        }
        _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());
        _require.resolve = function(request) {
          return Module._resolveFilename(request, _module);
        };
      }
    }
    o = {};
    for (k in options) {
      if (!__hasProp.call(options, k)) continue;
      v = options[k];
      o[k] = v;
    }
    o.bare = true;
    js = compile(code, o);
    if (sandbox === global) {
      return vm.runInThisContext(js);
    } else {
      return vm.runInContext(js, sandbox);
    }
  };

  lexer = new Lexer;

  parser.lexer = {
    lex: function() {
      var tag, _ref2;
      _ref2 = this.tokens[this.pos++] || [''], tag = _ref2[0], this.yytext = _ref2[1], this.yylineno = _ref2[2];
      return tag;
    },
    setInput: function(tokens) {
      this.tokens = tokens;
      return this.pos = 0;
    },
    upcomingInput: function() {
      return "";
    }
  };

  parser.yy = require('./nodes');

  exports.iced = iced.runtime;

}).call(this);

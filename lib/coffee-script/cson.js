// Generated by eXtraCoffeeScript 1.6.2
(function() {
  var BANNER, CoffeeScript, EventEmitter, SWITCHES, compileOptions, compilePath, compileScript, compileStdio, exec, exists, fs, helpers, loadRequires, notSources, optionParser, optparse, opts, outputPath, parseOptions, path, printLine, printWarn, procJSON, removeSource, sourceCode, sources, spawn, timeLog, unwatchDir, usage, version, wait, watch, watchDir, watchers, writeJs, _ref;

  fs = require('fs');

  path = require('path');

  helpers = require('./helpers');

  optparse = require('./optparse');

  CoffeeScript = require('./coffee-script');

  _ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

  EventEmitter = require('events').EventEmitter;

  exists = fs.exists || path.exists;

  helpers.extend(CoffeeScript, new EventEmitter);

  printLine = function(line) {
    return process.stdout.write(line + '\n');
  };

  printWarn = function(line) {
    return process.stderr.write(line + '\n');
  };

  BANNER = 'Usage: cson [options] path/to/script.cson\n\nIf called without options, `cson` will run your script.';

  SWITCHES = [['-o', '--output [DIR]', 'set the output directory for compiled JSON'], ['-e', '--eval', 'pass a string from the command line as input'], ['-p', '--print', 'print out the compiled JSON'], ['-s', '--stdio', 'listen for and compile scripts over stdio'], ['-w', '--watch', 'watch scripts for changes and rerun commands'], ['-b', '--beautify', 'beautify compiled JSON conflict with --raw'], ['--space [SPACE]', 'beautify compiled JSON with space need --beautify'], ['-r', '--raw', 'return row compiled JSON without check and compact'], ['--safe', 'do not use eval to parse compiled JSON'], ['-h', '--help', 'display this help message'], ['-v', '--version', 'display the version number']];

  opts = {};

  sources = [];

  sourceCode = [];

  notSources = {};

  watchers = {};

  optionParser = null;

  exports.run = function() {
    var source, _i, _len, _results;
    parseOptions();
    if (opts.help) {
      return usage();
    }
    if (opts.version) {
      return version();
    }
    if (opts.watch && !fs.watch) {
      return printWarn("The --watch feature depends on Node v0.6.0+. You are running " + process.version + ".");
    }
    if (opts.stdio) {
      return compileStdio();
    }
    if (opts["eval"]) {
      return compileScript(null, sources[0]);
    }
    process.argv = process.argv.slice(0, 2).concat(opts.literals);
    process.argv[0] = 'cson';
    process.execPath = require.main.filename;
    _results = [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      _results.push(compilePath(source, true, path.normalize(source)));
    }
    return _results;
  };

  compilePath = function(source, topLevel, base) {
    return fs.stat(source, function(err, stats) {
      if (err && err.code !== 'ENOENT') {
        throw err;
      }
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        if (topLevel && source.slice(-7) !== '.cson') {
          source = sources[sources.indexOf(source)] = "" + source + ".cson";
          return compilePath(source, topLevel, base);
        }
        if (topLevel) {
          console.error("File not found: " + source);
          process.exit(1);
        }
        return;
      }
      if (stats.isDirectory()) {
        if (opts.watch) {
          watchDir(source, base);
        }
        return fs.readdir(source, function(err, files) {
          var file, index, _i, _len, _ref1, _results;
          if (err && err.code !== 'ENOENT') {
            throw err;
          }
          if ((err != null ? err.code : void 0) === 'ENOENT') {
            return;
          }
          files = files.map(function(file) {
            return path.join(source, file);
          });
          index = sources.indexOf(source);
          [].splice.apply(sources, [index, index - index + 1].concat(files)), files;
          [].splice.apply(sourceCode, [index, index - index + 1].concat(_ref1 = files.map(function() {
            return null;
          }))), _ref1;
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            _results.push(compilePath(file, false, base));
          }
          return _results;
        });
      } else if (topLevel || path.extname(source) === '.cson') {
        if (opts.watch) {
          watch(source, base);
        }
        return fs.readFile(source, function(err, code) {
          if (err && err.code !== 'ENOENT') {
            throw err;
          }
          if ((err != null ? err.code : void 0) === 'ENOENT') {
            return;
          }
          return compileScript(source, code.toString(), base);
        });
      } else {
        notSources[source] = true;
        return removeSource(source, base);
      }
    });
  };

  procJSON = function(code) {
    var e, from, json, obj, to;
    from = code.indexOf('{');
    to = code.lastIndexOf('}');
    if (from < 0 || to < 0) {
      throw 'Invalid JSON compiled, cannot find { or }';
    }
    json = code.slice(from, +to + 1 || 9e9);
    if (opts.raw && !opts.safe) {
      return json;
    }
    try {
      obj = JSON.parse(json);
      if (opts.raw && opts.safe) {
        return json;
      }
    } catch (_error) {
      e = _error;
      if (opts.safe) {
        throw 'Invalid JSON comiled, JSON.parse check failed (--safe)';
      }
      try {
        obj = eval(code);
        if (obj == null) {
          throw 'eval return null';
        }
      } catch (_error) {
        e = _error;
        throw 'Invalid JSON comiled for eval cannot parse';
      }
    }
    if (opts.beautify) {
      json = JSON.stringify(obj, null, opts.space);
      return json + '\n';
    } else {
      return JSON.stringify(obj);
    }
  };

  compileScript = function(file, input, base) {
    var err, o, options, t, task;
    o = opts;
    options = compileOptions(file);
    try {
      t = task = {
        file: file,
        input: input,
        options: options
      };
      CoffeeScript.emit('compile', task);
      t.output = procJSON(CoffeeScript.compile(t.input, t.options));
      CoffeeScript.emit('success', task);
      if (o.print) {
        return printLine(t.output.trim());
      } else {
        return writeJs(t.file, t.output, base);
      }
    } catch (_error) {
      err = _error;
      CoffeeScript.emit('failure', err, task);
      if (CoffeeScript.listeners('failure').length) {
        return;
      }
      if (o.watch) {
        return printLine(err.message + '\x07');
      }
      printWarn(err instanceof Error && err.stack || ("ERROR: " + err));
      return process.exit(1);
    }
  };

  compileStdio = function() {
    var code, stdin;
    code = '';
    stdin = process.openStdin();
    stdin.on('data', function(buffer) {
      if (buffer) {
        return code += buffer.toString();
      }
    });
    return stdin.on('end', function() {
      return compileScript(null, code);
    });
  };

  loadRequires = function() {
    var realFilename, req, _i, _len, _ref1;
    realFilename = module.filename;
    module.filename = '.';
    _ref1 = opts.require;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      req = _ref1[_i];
      require(req);
    }
    return module.filename = realFilename;
  };

  watch = function(source, base) {
    var compile, compileTimeout, e, prevStats, rewatch, watchErr, watcher;
    prevStats = null;
    compileTimeout = null;
    watchErr = function(e) {
      if (e.code === 'ENOENT') {
        if (sources.indexOf(source) === -1) {
          return;
        }
        try {
          rewatch();
          return compile();
        } catch (_error) {
          e = _error;
          return removeSource(source, base, true);
        }
      } else {
        throw e;
      }
    };
    compile = function() {
      clearTimeout(compileTimeout);
      return compileTimeout = wait(25, function() {
        return fs.stat(source, function(err, stats) {
          if (err) {
            return watchErr(err);
          }
          if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {
            return rewatch();
          }
          prevStats = stats;
          return fs.readFile(source, function(err, code) {
            if (err) {
              return watchErr(err);
            }
            compileScript(source, code.toString(), base);
            return rewatch();
          });
        });
      });
    };
    try {
      watcher = fs.watch(source, compile);
    } catch (_error) {
      e = _error;
      watchErr(e);
    }
    return rewatch = function() {
      if (watcher != null) {
        watcher.close();
      }
      return watcher = fs.watch(source, compile);
    };
  };

  watchDir = function(source, base) {
    var e, readdirTimeout, watcher;
    readdirTimeout = null;
    try {
      return watcher = fs.watch(source, function() {
        clearTimeout(readdirTimeout);
        return readdirTimeout = wait(25, function() {
          return fs.readdir(source, function(err, files) {
            var file, _i, _len, _results;
            if (err) {
              if (err.code !== 'ENOENT') {
                throw err;
              }
              watcher.close();
              return unwatchDir(source, base);
            }
            files = files.map(function(file) {
              return path.join(source, file);
            });
            _results = [];
            for (_i = 0, _len = files.length; _i < _len; _i++) {
              file = files[_i];
              if (!(!notSources[file])) {
                continue;
              }
              if (sources.some(function(s) {
                return s.indexOf(file) >= 0;
              })) {
                continue;
              }
              sources.push(file);
              sourceCode.push(null);
              _results.push(compilePath(file, false, base));
            }
            return _results;
          });
        });
      });
    } catch (_error) {
      e = _error;
      if (e.code !== 'ENOENT') {
        throw e;
      }
    }
  };

  unwatchDir = function(source, base) {
    var file, prevSources, toRemove, _i, _len, _results;
    prevSources = sources.slice(0);
    toRemove = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        file = sources[_i];
        if (file.indexOf(source) >= 0) {
          _results.push(file);
        }
      }
      return _results;
    })();
    _results = [];
    for (_i = 0, _len = toRemove.length; _i < _len; _i++) {
      file = toRemove[_i];
      _results.push(removeSource(file, base, true));
    }
    return _results;
  };

  removeSource = function(source, base, removeJs) {
    var index, jsPath;
    index = sources.indexOf(source);
    sources.splice(index, 1);
    sourceCode.splice(index, 1);
    if (removeJs) {
      jsPath = outputPath(source, base);
      return exists(jsPath, function(exists) {
        if (exists) {
          return fs.unlink(jsPath, function(err) {
            if (err && err.code !== 'ENOENT') {
              throw err;
            }
            return timeLog("removed " + source);
          });
        }
      });
    }
  };

  outputPath = function(source, base) {
    var baseDir, dir, filename, srcDir;
    filename = path.basename(source, path.extname(source)) + '.json';
    srcDir = path.dirname(source);
    baseDir = base === '.' ? srcDir : srcDir.substring(base.length);
    dir = opts.output ? path.join(opts.output, baseDir) : srcDir;
    return path.join(dir, filename);
  };

  writeJs = function(source, js, base) {
    var compile, jsDir, jsPath;
    jsPath = outputPath(source, base);
    jsDir = path.dirname(jsPath);
    compile = function() {
      if (js.length <= 0) {
        js = ' ';
      }
      return fs.writeFile(jsPath, js, function(err) {
        if (err) {
          return printLine(err.message);
        } else {
          return timeLog("compiled " + source);
        }
      });
    };
    return exists(jsDir, function(exists) {
      if (exists) {
        return compile();
      } else {
        return exec("mkdir -p " + jsDir, compile);
      }
    });
  };

  wait = function(milliseconds, func) {
    return setTimeout(func, milliseconds);
  };

  timeLog = function(message) {
    return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
  };

  parseOptions = function() {
    var i, o, source, _i, _len;
    optionParser = new optparse.OptionParser(SWITCHES, BANNER);
    o = opts = optionParser.parse(process.argv.slice(2));
    o.print = !!(o.print || (o["eval"] || o.stdio));
    o.beautify = !!o.beautify;
    if (o.space != null) {
      if (!o.beautify) {
        throw 'space need beautify is on';
      }
      if (/^\d+$/.test(o.space)) {
        o.space = o.space >>> 0;
      }
    } else {
      o.space = '\t';
    }
    o.raw = !!o.raw;
    if (o.help == null) {
      o.help = process.argv.length < 3;
    }
    if (o.beautify && o.raw) {
      throw 'beautify conflict with raw';
    }
    sources = o["arguments"];
    for (i = _i = 0, _len = sources.length; _i < _len; i = ++_i) {
      source = sources[i];
      sourceCode[i] = null;
    }
  };

  compileOptions = function(filename) {
    return {
      filename: filename,
      bare: true,
      runtime: opts.runtime
    };
  };

  usage = function() {
    return printLine((new optparse.OptionParser(SWITCHES, BANNER)).help());
  };

  version = function() {
    return printLine("CSON with eXtraCoffeeScript version " + CoffeeScript.VERSION);
  };

}).call(this);
